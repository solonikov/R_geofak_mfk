---
title: "Homework 7"
output: html_notebook
---

Импортируем пакеты:
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(googlesheets4)
library(ggrepel)
library(lubridate)
```

Загружаем данные из google-таблиц:
```{r}
# Каталог метеостанций:
metcatalog <- read_sheet('1InNM-zQbdhSlw1zmQPf9lPJvVr8waTqOq3G3Li6v4MU')

# Получаем индексы интересующих метеостанций:
indices <- metcatalog |>
              filter(NAME == 'Москва (центр, Балчуг)' |
                     NAME == 'Малое Сареево') |> 
           pull(ID) |> 
           as.character()
```
Создаём датафрейм
```{r}
# Читаем данные о погоде с метеостанций. Так как данные в таблице разбиты по
# вкладкам, каждая из которых соответствует отдельной метеостанции и названа её
# индексом, то читаем данные с помощью lapply, применяя функцию read_sheet к
# вектору индексов

df <- lapply(indices, read_sheet,
       ss = '1EHvMAuUoMtNbMzRCyOVZU81nB9yK48x7rpH2Rp56jrw',
       col_types = 'ccccccnnnnncnnnnnnn') |> 
  rlang::set_names(indices) |> 
  bind_rows(.id = 'ID') |> 
  mutate(ID = as.numeric(ID),
         Datetime = as.POSIXct(Datetime)) |> 
  # присоединяем датафрейм с информацией о метеостанциях:
  left_join(y = metcatalog, by = 'ID') |>
  # устанавливаем короткие имена колонок:
  rlang::set_names(c('ID', 'Datetime', 'Wdir', 'Wspd', 'Vis', 'Phen', 'Cloud',
                     'T', 'Td', 'F', 'Te', 'Tes', 'Comf', 'P', 'Po', 'Tmin',
                     'Tmax', 'R', 'R24', 'S', 'Name', 'Lon', 'Lat', 'H')) |> 
  # В колонке со скоростями ветра есть строки вида "число{число}". Очевидно, что
  # число до фигурных скобок является средним за период данного наблюдения
  # значением скорости ветра, поэтому во избежание потери информации при 
  # преобразовании к численному типу извечём часть строки до фигурных скобок:
  mutate(Wspd = stringr::str_extract(Wspd, '\\d*') |> as.numeric())
```
Создаём ночной датафрейм
```{r}
df_night <- df |> 
                filter(hour(Datetime) == 3 |
                       hour(Datetime) == 0)
```
Строим функции распределения температур и диаграммы размаха (боксплоты), на
которых сравним данные по двум метеостанциям.
Сперва строим шаблон графика:
```{r}
dens_template <- ggplot() +
  geom_density(aes(x = T, fill = Name), alpha = 0.5, linewidth = .2) +
  labs(x = 'Температура', y = 'Плотность распределения', fill = 'Метеостанция')
```
Применяем шаблон к общему набору даннных:
```{r}
dens_template + list(df)
```
Теперь строим график по ночным данным:
```{r}
dens_template + list(df_night)
```
На ночном графике отчётливо видно влияние городского острова тепла, так как
максимум функции плотности распределения наблюдается при температуре на
несколько градусов большей, чем на станции, расположенной в пригороде. На
дневном графике закономерность также видна, но в меньшей степени.

Построим боксплоты. Шаблон боксплота:
```{r}
box_template <- ggplot() +
                  geom_boxplot(aes(x = T, y = Name)) +
                  labs(x = 'Температура', y = 'Метеостанция') +
                  theme_bw()
```
По общему набору данных:
```{r}
box_template + list(df)
```
По ночным данным:
```{r}
box_template + list(df_night)
```
На боксплотах также видно влияние городского острова тепла: медианные
температуры на обоих графиках выше для городской метеостанции, в ночной период
различия выражены сильнее. Кроме того, для пригородной метеостанции характерен
слегка больший размах вариации при меньшем, чем у городской станции
межквартильном размахе. Распределение на ночном графике по пригородной станции
асимметричное (что следует из асимметрии "усов" боксплота).

Сравним средние значения и дисперсии температур с помощью тестов Стьюдента и
Фишера.
Тест Стьюдента (Уэлча) по общей выборке:
```{r}
t.test(df |> filter(Name == 'Москва (центр, Балчуг)') |> pull(T),
       df |> filter(Name == 'Малое Сареево') |> pull(T))
```
Средее значение температуры на городской метеостанции примерно на 2ºC выше, чем
на пригородной; p-значение очень мало, что позволяет  принять (не отвергать)
гипотезу о неравенстве средних. 
Тест Фишера по общей выборке:
```{r}
var.test(df |> filter(Name == 'Москва (центр, Балчуг)') |> pull(T),
       df |> filter(Name == 'Малое Сареево') |> pull(T))
```
Различие дисперсий температуры на метеостанциях невелико (так как их отношение
близко к единице) и статистически незначимо (высокое p-значение).

Проверим ночную выборку.
Тест Стьюдента (Уэлча) по ночной выборке:
```{r}
t.test(df_night |> filter(Name == 'Москва (центр, Балчуг)') |> pull(T),
       df_night |> filter(Name == 'Малое Сареево') |> pull(T))
```
Средее значение температуры на городской метеостанции ночью примерно на 3ºC 
выше, чем на пригородной; p-значение очень мало, что позволяет  принять (не
отвергать) гипотезу о неравенстве средних. Таким образом, влияние острова тепла
на температурный режим сильнее выражено в ночное время (3ºC против 2ºC по общей
выборке).
Тест Фишера по общей выборке:
```{r}
var.test(df_night |> filter(Name == 'Москва (центр, Балчуг)') |> pull(T),
       df_night |> filter(Name == 'Малое Сареево') |> pull(T))
```
Различие дисперсий ночной температуры на метеостанциях практически отсутствует
(так как их отношение примерно равно единице) и статистически незначимо (высокое
p-значение).

Получим датафрейм, в котором на каждый временной срез имеется разность
температур между городской и загородной метеостанцией, а также средняя по всем
метеостанциям (средняя по региону) скорость ветра.

Сперва получим датафрейм со средними по региону скоростями ветра:
```{r}
# Получаем имена всех листов таблицы с метеоданными (каждый лист соответствует
# отдельной метеостанции):
winddata <- sheet_names('1EHvMAuUoMtNbMzRCyOVZU81nB9yK48x7rpH2Rp56jrw') |> 
  # преобразуем в именованный вектор, в котором и сами элементы, и их имена --
  # это индексы метеостанций. Это нужно для того, чтобы дальше при склейке
  # списка датафреймов в один датафрейм в колонке ID был индекс станции:
  rlang::set_names() |> 
  # читаем данные по всем метеостанциям:
  lapply(read_sheet,
         ss = '1EHvMAuUoMtNbMzRCyOVZU81nB9yK48x7rpH2Rp56jrw',
         # уточняем колонки, чтобы не считывать всё полностью; индекс 2
         # позволяет считывать начиная со второй строчки (в первой строчке
         # содержатся заголовки):
         range = 'A2:C',
         col_names = c('Datetime', 'Wdir', 'Wspd'),
         col_types = 'c_c') |> 
  # склеиваем в один датафрейм:
  bind_rows(.id = 'ID') |>
  # выбираем из колонки со скоростью ветра только числа без дополнительной
  # информации, чтобы не получить NA при преобразовании к численному типу;
  # дату преобразуем к POSIXct из строкового типа
  mutate(
    ID = as.numeric(ID),
    Datetime = as.POSIXct(Datetime),
    Wspd = stringr::str_extract(Wspd, '\\d*') |> as.numeric())
```
Обобщим данные о скорости ветра по разным метеостанциям, чтобы получить среднее
по региону:
```{r}
region_wind <- winddata |> 
  group_by(Datetime) |> 
  summarize(RegWspd = mean(Wspd))
```
Итоговый датафрейм с разностями температур и средними по региону скоростями
ветра:
```{r}
df_TW <- df |>
  select(Name, Datetime, T) |> # выбираем только нужные колонки
  pivot_wider(names_from = Name, # приводим к широкому виду из длинного
              values_from = T) |> 
  # вычисляем разность температур по каждому временному срезу:
  transmute(Datetime = Datetime, 
            dT = `Москва (центр, Балчуг)` - `Малое Сареево`) |> 
  # добавляем данные о скорости ветра
  inner_join(y = region_wind, by = 'Datetime') |> 
  na.omit()
```
Ночная версия этого датафрейма:
```{r}
df_TW_night <-  df_TW |> 
  filter(hour(Datetime) == 3 |
         hour(Datetime) == 0)
```
Построим диаграммы рассеяния между скоростью ветра и разностью температур.
Диаграмма рассеяния по всему датафрейму:
```{r}
ggplot(df_TW, aes(y = RegWspd, x = dT)) +
  geom_point() +
  xlab('Разность температур, ºC') +
  ylab('Средняя скорость ветра, м/с')
```
Диаграмма рассеяния по ночному датафрейму:
```{r}
ggplot(df_TW_night, aes(y = RegWspd, x = dT)) +
  geom_point() +
  xlab('Разность температур, ºC') +
  ylab('Средняя скорость ветра, м/с')
```
По графикам видна обратная связь между скоростью ветра и разностью температур:
чем ниже скорость ветра, тем выраженнее эффект влияния острова тепла. При этом
связь нелинейная -- разность температур достаточно высока при средней скорости
ветра ниже 1 м/с и по мере роста скорости резко снижается. На общем графике
нелинейность выражена сильнее, во многом за счёт большего количества точек с 
высокой скоростью ветра, чем на ночном графике.

Попробуем привести зависимость к линейной с помощью преобразований и добавим на
графики линию регрессии.
По общему датафрейму:
```{r}
ggplot(df_TW, aes(y = RegWspd, x = dT)) +
  geom_point() +
  geom_smooth(method = 'lm') +
  scale_y_log10() +
  xlab('Разность температур, ºC') +
  ylab('Логарифм средней скорости ветра, м/с')
```
По ночному датафрейму:
```{r}
ggplot(df_TW_night, aes(y = RegWspd, x = dT)) +
  geom_point() +
  geom_smooth(method = 'lm') +
  scale_y_log10() +
  xlab('Разность температур, ºC') +
  ylab('Логарифм средней скорости ветра, м/с')
```
Прологарифмировав значения скорости ветра, мы приблизили их связь со значениями
разности температур к линейному виду. Связь обратная: разность температур и,
соответственно, влияние эффекта острова тепла тем выше, чем меньше логарифм
средней скорости ветра. На ночном графике связь весьма близка к линейной, а на
общем графике  при этом наблюдается концентрация точек в области высоких
скоростей ветра и низких разностей температур. Таким образом, можно
предположить, что влияние городского острова тепла более выражено в ночное
время.
Выполним корреляционный тест между разностью температур (y) и логарифмом
скорости ветра (x).
Для общей выборки:
```{r}
cor.test(x = log10(df_TW$RegWspd),
         y = df_TW$dT)
```
Корреляционный тест подтверждает обратную связь величин: доверительный интервал
(с вероятностью 0.95) коэффициента корреляции находится в диапазоне от -0.76 до
-0.69, его математическое ожидание составляет -0.73.
По ночной выборке:
```{r}
cor.test(x = log10(df_TW_night$RegWspd),
         y = df_TW_night$dT)
```
Для ночной выборки обратная корреляция ещё более выражена: коэффициент
корреляции с вероятностью 95% лежит в диапазоне от -0.84 до -0.72, его 
математическое ожидание составляет -0.79. 

Построим модель линейной регрессии между скоростью ветра (x) и разностью
температур (y), применив к x логарифмическое преобразование.
```{r}
# Для общей выборки:
my_mdl <- lm(dT ~ log10(RegWspd), data = df_TW)
# Для ночной выборки:
my_mdl_night <- lm(dT ~ log10(RegWspd), data = df_TW_night)
```
Коэффициенты моделей:
```{r}
# По общей выборке:
coef(my_mdl)
```
```{r}
# По ночной выборке:
coef(my_mdl_night)
```
Подробная сводка о качестве модели:
```{r}
summary(my_mdl)
```
Регрессионная модель построена с коэффициентом детерминации 0.53.
По ночным данным:
```{r}
summary(my_mdl_night)
```
Регрессионная модель по ночным данным построена с коэффициентом детерминации
0.62. Таким образом, модель лучше описывает связь скорости ветра и разности
температур по ночным данным, чем по общему датасету.

Визуализируем модели.
Модель для общей выборки:
```{r}
mdl_df <- tibble(dT = fitted(my_mdl),
                 RegWspd = df_TW$RegWspd)

ggplot(df_TW, aes(x = RegWspd, y = dT)) +
  geom_point(alpha = 0.5) +
  geom_line(data = mdl_df, aes(RegWspd, dT), color = 'red', linewidth = 1) +
  theme_bw() +
  xlab('Средняя скорость ветра, м/с') +
  ylab('Разность температур, ºC')
```
Модель для ночной выборки:
```{r}
mdl_df_night <- tibble(dT = fitted(my_mdl_night),
                 RegWspd = df_TW_night$RegWspd)

ggplot(df_TW_night, aes(x = RegWspd, y = dT)) +
  geom_point(alpha = 0.5) +
  geom_line(data = mdl_df_night, aes(RegWspd, dT),
            color = 'red', linewidth = 1) +
  theme_bw() +
  xlab('Средняя скорость ветра, м/с') +
  ylab('Разность температур, ºC')
```
















