data.frame(months = month.name,
a = sapply(X = c('a', 'b', 'c'), FUN = rep, times = 4) |> c())
data.frame(months = month.name,
a = sapply(X = c('a', 'b', 'c'), FUN = rep, times = 4) |> c() |> as.factor())
seq(0, 2, length.out = 12)
rm(list = ls())
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
month_data <- data.frame(months = month.name,
season = sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c() |> as.factor(),
a = rnorm(12, mean = 5, sd = 1.5),
b = seq(0, 2, length.out = 12),
c = rnorm(12, mean = -5, sd = 20) * 5)
month_data
sapply(X = c('a', 'b', 'c'), FUN = rep, times = 3) |> c()
sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c() |> "["(1, 3)
sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()[-1]
sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c() |> .[-1]
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
season_col
rm(list = ls())
#### Задание 1
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 1.5),
b = seq(0, 2, length.out = 12),
c = rnorm(12, mean = -5, sd = 20) * 5)
month_data
month_data |> View()
month_data |> str()
rm(list = ls())
#### Задание 1
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 1.5),
b = seq(0, 2, length.out = 12),
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
rm(list = ls())
#### Задание 1
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 1.5),
b = seq(0, 2, length.out = 12),
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
library(reshape2)
month_data_long <- month_data |> melt(id.vars = 'months')
month_data_long
month_data_long <- month_data |> melt(id.vars = 'season')
month_data_long
month_data
month_data_long <- month_data |> melt()
month_data_long
rm(list = ls())
#### Задание 1
## сделать из вектора названий месяцев матрицы 3х4 двух видов - с заполнением по строкам и по столбцам
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
## сделать датафрейм со столбцами (названия столбцов любые): названия месяцев, данные от трех переменных (всего 4 столбца) - три вектора нормально или равномерно распределенных величин
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 1.5),
b = seq(0, 2, length.out = 12),
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
## "вытянуть" датафрейм из широкого формата в длинный
library(reshape2)
month_data_long <- melt(month_data)
print(month_data_long)
rm(list = ls())
#### Задание 1
## сделать из вектора названий месяцев матрицы 3х4 двух видов - с заполнением по строкам и по столбцам
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
## сделать датафрейм со столбцами (названия столбцов любые): названия месяцев, данные от трех переменных (всего 4 столбца) - три вектора нормально или равномерно распределенных величин
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 1.5),
b = seq(0, 2, length.out = 12),
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
## "вытянуть" датафрейм из широкого формата в длинный
library(reshape2)
month_data_long <- melt(month_data)
print(month_data_long)
#### Задание 4
## нарисовать точечно-линейный график от этих трех переменных
library(ggplot2)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_point()
rm(list = ls())
#### Задание 1
## сделать из вектора названий месяцев матрицы 3х4 двух видов - с заполнением по строкам и по столбцам
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
## сделать датафрейм со столбцами (названия столбцов любые): названия месяцев, данные от трех переменных (всего 4 столбца) - три вектора нормально или равномерно распределенных величин
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 1.5) * 4,
b = seq(0, 2, length.out = 12) * 3,
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
## "вытянуть" датафрейм из широкого формата в длинный
library(reshape2)
month_data_long <- melt(month_data)
print(month_data_long)
#### Задание 4
## нарисовать точечно-линейный график от этих трех переменных
library(ggplot2)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_point()
rm(list = ls())
#### Задание 1
## сделать из вектора названий месяцев матрицы 3х4 двух видов - с заполнением по строкам и по столбцам
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
## сделать датафрейм со столбцами (названия столбцов любые): названия месяцев, данные от трех переменных (всего 4 столбца) - три вектора нормально или равномерно распределенных величин
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 1.5) * 4,
b = seq(-5, 5, length.out = 12) * 3,
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
## "вытянуть" датафрейм из широкого формата в длинный
library(reshape2)
month_data_long <- melt(month_data)
print(month_data_long)
#### Задание 4
## нарисовать точечно-линейный график от этих трех переменных
library(ggplot2)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_point()
rm(list = ls())
#### Задание 1
## сделать из вектора названий месяцев матрицы 3х4 двух видов - с заполнением по строкам и по столбцам
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
## сделать датафрейм со столбцами (названия столбцов любые): названия месяцев, данные от трех переменных (всего 4 столбца) - три вектора нормально или равномерно распределенных величин
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 7.5) * 4,
b = seq(-10, 10, length.out = 12) * 3,
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
## "вытянуть" датафрейм из широкого формата в длинный
library(reshape2)
month_data_long <- melt(month_data)
print(month_data_long)
#### Задание 4
## нарисовать точечно-линейный график от этих трех переменных
library(ggplot2)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_point()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_point(size = 3) +
geom_line()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_point(size = 3) +
geom_line()
rm(list = ls())
#### Задание 1
## сделать из вектора названий месяцев матрицы 3х4 двух видов - с заполнением по строкам и по столбцам
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
## сделать датафрейм со столбцами (названия столбцов любые): названия месяцев, данные от трех переменных (всего 4 столбца) - три вектора нормально или равномерно распределенных величин
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 7.5) * 4,
b = seq(-10, 10, length.out = 12) * 3,
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
## "вытянуть" датафрейм из широкого формата в длинный
library(reshape2)
month_data_long <- melt(month_data)
print(month_data_long)
#### Задание 4
## нарисовать точечно-линейный график от этих трех переменных
library(ggplot2)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_point() +
geom_line()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_line()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable)) +
geom_point()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = 1)) +
geom_point()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = 1)) +
geom_linet()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = 1)) +
geom_line()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = 3)) +
geom_line()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = 3)) +
geom_point() +
geom_line()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = variable)) +
geom_point() +
geom_line()
ggplot(data = month_data_long, aes(x = months |> as.factor(), y = value, color = variable, group = variable)) +
geom_point() +
geom_line()
ggplot(data = month_data_long, aes(x = as.factor(months), y = value, color = variable, group = variable)) +
geom_point() +
geom_line()
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = variable)) +
geom_point() +
geom_line() +
scale_x_discrete(limits = month.name)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = variable)) +
geom_point(size = 2.5) +
geom_line(size = 1.5) +
scale_x_discrete(limits = month.name)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = variable)) +
geom_point(size = 1.5) +
geom_line(size = .75) +
scale_x_discrete(limits = month.name)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = variable)) +
geom_point(size = 1.75) +
geom_line(size = .75) +
scale_x_discrete(limits = month.name)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = variable)) +
geom_point(size = 2) +
geom_line(size = .75) +
scale_x_discrete(limits = month.name)
rm(list = ls())
rm(list = ls())
#### Задание 1
## сделать из вектора названий месяцев матрицы 3х4 двух видов - с заполнением по строкам и по столбцам
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
## сделать датафрейм со столбцами (названия столбцов любые): названия месяцев, данные от трех переменных (всего 4 столбца) - три вектора нормально или равномерно распределенных величин
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 7.5) * 4,
b = seq(-10, 10, length.out = 12) * 3,
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
## "вытянуть" датафрейм из широкого формата в длинный
library(reshape2)
month_data_long <- melt(month_data)
print(month_data_long)
#### Задание 4
## нарисовать точечно-линейный график от этих трех переменных
library(ggplot2)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = variable)) +
geom_point(size = 2) +
geom_line(size = .75) +
scale_x_discrete(limits = month.name)
rm(list = ls())
#### Задание 1
## сделать из вектора названий месяцев матрицы 3х4 двух видов - с заполнением по строкам и по столбцам
months_by_row <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = T)
months_by_column <- matrix(data = month.name, nrow = 3, ncol = 4, byrow = F)
print(months_by_row)
print(months_by_column)
#### Задание 2
## сделать датафрейм со столбцами (названия столбцов любые): названия месяцев, данные от трех переменных (всего 4 столбца) - три вектора нормально или равномерно распределенных величин
season_col <- sapply(X = c('winter', 'spring', 'summer', 'fall'),
FUN = rep, times = 3) |> c()
season_col <- c(season_col[-1], season_col[1])
month_data <- data.frame(months = month.name,
season = season_col |> as.factor(),
a = rnorm(12, mean = 5, sd = 7.5) * 4,
b = seq(-10, 10, length.out = 12) * 3,
c = rnorm(12, mean = -5, sd = 20) * 5)
print(month_data)
#### Задание 3
## "вытянуть" датафрейм из широкого формата в длинный
library(reshape2)
month_data_long <- melt(month_data)
print(month_data_long)
#### Задание 4
## нарисовать точечно-линейный график от этих трех переменных
library(ggplot2)
ggplot(data = month_data_long, aes(x = months, y = value, color = variable, group = variable)) +
geom_point(size = 2) +
geom_line(size = .75) +
scale_x_discrete(limits = month.name)
install.packages("tidyverse")
install.packages("writexl")
getwd()
setwd("C:/Users/boss/Desktop/R_mfk/my_folder")
getwd
getwd()
quakes
quakes %>% head()
# Таблица quakes из пакета datasets содержит магнитуду землетрясений в поле mag.
# Используя функции dplyr и пайп-оператор, создайте на ее основе таблицу с
# частотой (количеством штук) землетрясений каждой магнитуды.
#
# Подсказка: при выполнении агрегирования используйте функцию n(), которая
# возвращает количество строк в группе.
library(dplyr)
quakes %>% head()
data(quakes)
quakes
quakes %>%
group_by(mag) %>%
summarize()
quakes %>%
group_by(mag) %>%
summarize(count = n())
# Таблица quakes из пакета datasets содержит магнитуду землетрясений в поле mag.
# Используя функции dplyr и пайп-оператор, создайте на ее основе таблицу с
# частотой (количеством штук) землетрясений каждой магнитуды.
#
# Подсказка: при выполнении агрегирования используйте функцию n(), которая
# возвращает количество строк в группе.
library(dplyr)
data(quakes)
quakes %>%
group_by(mag) %>%
summarize(count = n()) -> quakesStats
quakeStats %>% View()
library(dplyr)
data(quakes)
quakeStats = quakes %>%
group_by(mag) %>%
summarize(count = n())
quakeStats %>% View()
# # УПРАЖНЕНИЕ 1
# Таблица quakes из пакета datasets содержит магнитуду землетрясений в поле mag.
# Используя функции dplyr и пайп-оператор, создайте на ее основе таблицу с
# частотой (количеством штук) землетрясений каждой магнитуды.
#
# Подсказка: при выполнении агрегирования используйте функцию n(), которая
# возвращает количество строк в группе.
library(dplyr)
data(quakes)
quakeStats = quakes %>%
group_by(mag) %>%
summarize(count = n())
quakeStats %>% View()
# Таблица storms из пакета dplyr содержит увлекательные данные трекинга
# тропических циклонов c 1975 по 2015 год. Используя функции dplyr и
# пайп-оператор, создайте таблицу в которой зафиксировано: название циклона, дата
# начала, дата окончания, продолжительность в днях, максимальная скорость ветра,
# минимальное давление. Отсортируйте циклоны сначала по максимальной скорости
# ветра (по убыванию), затем по давлению (по возрастанию). Оформите результат в
# виде одного конвейера манипуляций.
#
# Подсказка: перед выполнением агрегирования на основе существующих полей
# создайте новое поле, в котором хранится дата события, имеющая тип Date. Это
# позволит вам правильно вычислить продолжительность в днях. Чтобы создать строку
# для преобразования в дату, используйте функцию paste(), подставив в нее поля,
# составляющие даты, и укажите необходимый разделитель в параметре sep(). После
# агрегирования данных и перед сортировкой вызовите ungroup(), иначе вы будете
# сортировать внутри каждой группы, а вам нужно сортировать результаты
# группировки.
library(dplyr)
data(storms)
storms %>% head()
# Таблица storms из пакета dplyr содержит увлекательные данные трекинга
# тропических циклонов c 1975 по 2015 год. Используя функции dplyr и
# пайп-оператор, создайте таблицу в которой зафиксировано: название циклона, дата
# начала, дата окончания, продолжительность в днях, максимальная скорость ветра,
# минимальное давление. Отсортируйте циклоны сначала по максимальной скорости
# ветра (по убыванию), затем по давлению (по возрастанию). Оформите результат в
# виде одного конвейера манипуляций.
#
# Подсказка: перед выполнением агрегирования на основе существующих полей
# создайте новое поле, в котором хранится дата события, имеющая тип Date. Это
# позволит вам правильно вычислить продолжительность в днях. Чтобы создать строку
# для преобразования в дату, используйте функцию paste(), подставив в нее поля,
# составляющие даты, и укажите необходимый разделитель в параметре sep(). После
# агрегирования данных и перед сортировкой вызовите ungroup(), иначе вы будете
# сортировать внутри каждой группы, а вам нужно сортировать результаты
# группировки.
library(dplyr)
data(storms)
storms %>% head()
storms %>%
mutate(date = as.Date(paste(day, month, year, sep = '-'))) %>%
group_by(name, year) %>%
summarize(minDate = min(date),
maxDate = max(date),
duration = maxDate - minDate,
maxWind = max(wind),
minPressure = min(pressure))
storms %>%
mutate(date = as.Date(paste(year, month, day, sep = '-'))) %>%
group_by(name, year) %>%
summarize(minDate = min(date),
maxDate = max(date),
duration = maxDate - minDate,
maxWind = max(wind),
minPressure = min(pressure))
storms %>%
mutate(date = as.Date(paste(year, month, day, sep = '-'))) %>%
group_by(name, year) %>%
summarize(minDate = min(date),
maxDate = max(date),
duration = maxDate - minDate,
maxWind = max(wind),
minPressure = min(pressure)) %>%
ungroup() %>%
arrange(desc(maxWind), minPressure)
# Таблица storms из пакета dplyr содержит увлекательные данные трекинга
# тропических циклонов c 1975 по 2015 год. Используя функции dplyr и
# пайп-оператор, создайте таблицу в которой зафиксировано: название циклона, дата
# начала, дата окончания, продолжительность в днях, максимальная скорость ветра,
# минимальное давление. Отсортируйте циклоны сначала по максимальной скорости
# ветра (по убыванию), затем по давлению (по возрастанию). Оформите результат в
# виде одного конвейера манипуляций.
#
# Подсказка: перед выполнением агрегирования на основе существующих полей
# создайте новое поле, в котором хранится дата события, имеющая тип Date. Это
# позволит вам правильно вычислить продолжительность в днях. Чтобы создать строку
# для преобразования в дату, используйте функцию paste(), подставив в нее поля,
# составляющие даты, и укажите необходимый разделитель в параметре sep(). После
# агрегирования данных и перед сортировкой вызовите ungroup(), иначе вы будете
# сортировать внутри каждой группы, а вам нужно сортировать результаты
# группировки.
library(dplyr)
data(storms)
storms %>%
mutate(date = as.Date(paste(year, month, day, sep = '-'))) %>%
group_by(name, year) %>%
summarize(minDate = min(date),
maxDate = max(date),
duration = maxDate - minDate,
maxWind = max(wind),
minPressure = min(pressure)) %>%
ungroup() %>%
arrange(desc(maxWind), minPressure) %>%
View()
